/*
 * config.cpp
 *
 * Parses program arguments and returns Config object
 *
 * Note: change this file to parse program arguments
 *
 * University of Toronto
 * Fall 2019
 */

#include "config.h"
#include "player.h"
#include "shoe.h"
#include <cstdio>
#include <cstring>
#include <iostream>

static int usage(const char * prog) {
	fprintf(stderr, "usage: %s [-h] [-f FILE|-i SEED [-r FILE]] [[-s] -a FILE NUM]\n", prog);
	fprintf(stderr, "Options:\n");
	fprintf(stderr, " -h:\tDisplay this message\n");
	fprintf(stderr, " -f:\tUse file-based shoe\n");
	fprintf(stderr, " -i:\tUse random-based shoe (default)\n");
	fprintf(stderr, " -r:\tRecord random-based shoe to file\n");
	fprintf(stderr, " -a:\tPlay automatically using strategy chart\n");
	fprintf(stderr, " -s:\tSilent mode\n");
	fprintf(stderr, " FILE:\tFile name for associated option\n");
	fprintf(stderr, " SEED:\trandom seed\n");
	fprintf(stderr, " NUM:\tnumber of hands to be played\n");
	return -1;
}

// TODO: Clean up code, very messy at the moment
// TODO: Check if need to always specify a random seed or randomly generated by default
// TODO: Refactor to use a mapping, and isolate options and arguments
// i.e. {-f: 1, -i: 1, -r: 1, -a: 2, -s: 0}
int Config::process_arguments(int argc, const char * argv[]) {

	// Note: Provided in default code
    if (argc == 2 && (strcmp(argv[1], "-h") == 0)) {
		return usage(argv[0]);
	}

	// Argument parsing here
    const char* optv[] = {"-f", "-i", "-r", "-a", "-s"};
    int optc = 5;
    char target = 0;

    const char* afile = nullptr; // strategy_file
    const char* ffile = nullptr; // shoe_file
    const char* rfile = nullptr; // record_file
	long anum = -1; // num_hands
    long iseed = -1; // random_seed
    bool sflag = false; // silent

    // Search exclusively for -h option
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-h") == 0)
			return usage(argv[0]);
    }

    // Search for other options
    for (int i = 1; i < argc; i++) {
        const char* opt = argv[i];

        // Retrieve next argument
        // Need to rely on loop to avoid OutOfIndex access
        if (target != 0) {

            // Check if next argument is not an option
            for (int j = 0; j < optc; j++) {
                if (strcmp(opt, optv[j]) == 0) {
					if (target == 'A') {
						std::cerr << "Error: must specify number of hands when playing automatically." << std::endl;
					} else {
						std::cerr << argv[0] << ": option requires an argument -- '" << (char)tolower(target) << "'" << std::endl;
					}
                    return usage(argv[0]);
                }
            }

            // Save argument
            switch (target) {

                case 'f': {
					ffile = opt;
					target = 0;
					break;
				}

                case 'i': {
					char *pEnd;
			        iseed = strtol(opt, &pEnd, 10);
			        if ((*pEnd)||(iseed < 0)) {
						std::cout << "Error: SEED must be a non-negative integer." << std::endl;
						return usage(argv[0]);
					}
					target = 0;
					break;
				}

                case 'r': {
					rfile = opt;
					target = 0;
					break;
				}

                case 'a': {
					afile = opt;
					target = 'A'; // Special case for "-a" since it accepts two arguments
					break;
				}

				case 'A': {
					char *pEnd;
			        anum = strtol(opt, &pEnd, 10);
			        if ((*pEnd)||(anum <= 0)) {
						std::cout << "Error: NUM must be a natural number." << std::endl;
						return usage(argv[0]);
					}
					target = 0;
					break;
				}
            }
        }

        // Specify all valid options
        else {
			bool opt_flag = false;
            for (int j = 0; j < optc; j++) {
                if (strcmp(opt, optv[j]) == 0) {
					opt_flag = true;
                    // Special case for "-s", no need for argument parsing
                    if (strcmp(opt, "-s") == 0) {
                        if (sflag) {
                            std::cerr << "Error: too many -s options specified." << std::endl;
                            return usage(argv[0]);
                        }
                        sflag = true;

                    } else {
                        target = opt[1];

                        // Check if option already specified, excluding "-s"
                        bool manyOptionFlag = false;
                        switch (target) {
                            case 'f': if (ffile != nullptr) manyOptionFlag = true; break;
                            case 'r': if (rfile != nullptr) manyOptionFlag = true; break;
                            case 'a': if (afile != nullptr) manyOptionFlag = true; break;
                            case 'i': if (iseed != -1) manyOptionFlag = true; break;
                        }
                        if (manyOptionFlag) {
                            std::cerr << "Error: too many -" << target << " options specified." << std::endl;
                            return usage(argv[0]);
                        }

                        //std::cout << "[STATUS] Target: " << target << std::endl;
                    }
                    break;
                }
            }
			if (!opt_flag) {
				std::cerr << "Unknown option -- \'" << opt << '\'' << std::endl;
				return usage(argv[0]);
			}
        }
    }

    // Check if arguments are still needed
    if (target != 0) {
		if (target == 'A') {
			std::cerr << "Error: must specify number of hands when playing automatically." << std::endl;
		} else {
			std::cerr << argv[0] << ": option requires an argument -- '" << (char)tolower(target) << "'" << std::endl;
		}
		return usage(argv[0]);
    }
	if ((ffile != nullptr)&&(iseed != -1)) {
		std::cerr << "Error: cannot choose both file and random-based shoe." << std::endl;
		return usage(argv[0]);
	}
	if ((rfile != nullptr)&&(iseed == -1)) {
		std::cerr << "Error: recording is only available for random-based shoe." << std::endl;
		return usage(argv[0]);
	}
	if ((sflag)&&(afile == nullptr)) {
		std::cerr << "Error: silent mode is only available when playing automatically." << std::endl;
		return usage(argv[0]);
	}
	std::cout << std::endl;

    // Activate function based on flags (non-empty values)
	// std::cout << "[STATUS] ffile = " << ffile << std::endl;
    // std::cout << "[STATUS] iseed = " << iseed << std::endl;
    // std::cout << "[STATUS] rfile = " << rfile << std::endl;
    // std::cout << "[STATUS] afile = " << afile << std::endl;
    // std::cout << "[STATUS] anum = " << anum << std::endl;

	// Assign fields
	strategy_file = afile;
	shoe_file = ffile;
	record_file = rfile;
	num_hands = anum;
	random_seed = iseed;
	silent = sflag;

	// Instantiate Player and Shoe objects
	player = Player::factory(this);
	if (player == nullptr) {
		fprintf(stderr, "Error: cannot instantiate Player. (bad file?)\n");
		return usage(argv[0]);
	}
	shoe = Shoe::factory(this);
	if (shoe == nullptr) {
		fprintf(stderr, "Error: cannot instantiate Shoe. (bad file?)\n");
		return usage(argv[0]);
	}

	return 0;
}

Config::~Config()
{
	if (player != nullptr)
		delete player;

	if (shoe != nullptr)
		delete shoe;
}
